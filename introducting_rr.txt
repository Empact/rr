= Introducting RR

I'm pleased to introduce a new Test Double framework names RR, which is short for Double Ruby.
A Test Double is [double description]. You can read more about test doubles at http://xunitpatterns.com/Test%20Double.html.

RR supports the following constructs:
 * Mock
 * Stub
 * Probe
 * instance_of

== Mock
  real_user = User.new
  mock(User).find('2') {real_user}

The previous example overrides the User.find method and returns real_user. It also sets an expectation
that the find method will receive the argument '2' once.

== Stub
  user = User.new
  my_article = articles(:my_article)
  stub(user).can_edit?(my_article) {true}

The previous example overrides can_edit?. When the method receives the article, it returns true.

== Probe
A probe is a test double strategy that lets the real method implementation be called, and allows you
to intercept the return value, and possibly inject you own replacement return value.

  my_article = articles(:my_article)
  mock.probe(User).find('2') do |real_user|
    stub.probe(real_user).can_edit?(my_article) {true}
    real_user
  end

The previous example, lets the real User.find method call happen, and intercepts its return value inside
of the block.

The real_user's can_edit? method is then stubbed and probed to return true.

=== Thats nice, how is it useful?
As with any tool, Mocks and Stubs have limitations.
For example, mocks alone do not verify that the mocked out method conforms to the real object's interface.
Probes solve this issue.

Adding a probe ensures that:
 * The method call to User.find is valid
 * The return value of User.find is available to validate and/or add test doubles to
 * The method call to real_user.can_edit? is valid

=== I don't use Mocks. Why should I care?
State based testing is often the simplest and most straightforward way to make assertions.
However Interaction assertions can serve as good documentation of how your system fits together.
Interaction tests can also aid you in making your tests easier to set up and removing coupling between tests.

Lets compare the state and interaction testing approaches in the can edit article example for the
ArticlesController#edit action:

==== State Based Example
  user = users(:bob)
  login(user)
  my_article = articles(:my_article)
  user.can_edit?(my_article).should == false

  proc do
    post :edit, :id => my_article.id, :body => "Hello everybody"
  end.should raise_error(SecurityTrangressionError)

==== Interaction Based Example
  user = users(:bob)
  login(user)
  my_article = articles(:my_article)
  mock.probe(user).can_edit? {false}

  proc do
    post :edit, :id => my_article.id, :body => "Hello everybody"
  end.should raise_error(SecurityTrangressionError)

These two examples are interesting because they verify slight different things.
The mock example states that when can_edit? with @article is called and returns false, a SecurityTrangressionError
is raised.
The state example gives information that bob cannot edit the article, and from that one can infer that
bob trying to edit the article will raise a SecurityTrangressionError.

The state based example is more brittle because it requires @bob to be set up in a way where he cannot
edit the article. That requires knowledge about how User.can_edit? is implemented, which increases behaviour coupling.

So if the fixtures change to where bob can edit the article, then the spec will fail. It is reasonable
to assume that the coupling in this case is not that serious because the fixtures will probably not often
change in such a way where bob can edit my_article. Changes do happen though.


Here is a view example that renders counts:
==== State Based Example
  user = users(:bob)
  user.articles.count.should == 5
  user.articles.comments.count.should == 15
  user.gold_stars.count.should == 0

  render :template => "users/show"
  response.body.should include("Articles Posted: 5")
  response.body.should include("Comments Received: 15")
  response.body.should include("Gold Stars Received: 0")

==== Interaction Based Example
  user = User.new
  mock.probe(user.articles).count {5}
  mock.probe(user.articles.comments).count {15}
  mock.probe(user.gold_stars).count {80}

  render :template => "users/show"
  response.body.should include("Articles Posted: 5")
  response.body.should include("Comments Received: 15")
  response.body.should include("Gold Stars Received: 80")

In these examples, it is fair to expect the counts derived from the fixtures to change quite often.
Decoupling the counts from your fixtures yields more of a benefit because the interaction based example
will not need to be changed as often as the state based example.

The interaction based example also provides the benefits of
 * being faster because there is no database access
 * providing more focus because non-count user data is not important to this example (the interaction example
   ignores the user data while the state based approach includes the user data)
 * not requiring you to change the fixture data to provide add "Gold Stars Received" because having
   "Gold Stars Received: 0" is almost meaningless (It could easily be calling count on something else
   that returns 0)

=== State vs. Interaction Based testing?
The examples I provided favor interaction based testing. This does not mean all testing should be
done with interaction testing. There are many situations where state based testing is more
straightforward and no more coupled than an interaction based test.

Please pick the right toolset for your situation. In the future, I will blog about different situations
and the trade-offs of using a state based approach, and/or an interaction based approach.

=== Extremely Bad Examples
Since this is a blog post, the examples are short and relatively benign.
However, I'm sure you can look at any of your projects and see where state and/or interaction
based testing has been overused and abused.
Expanding your toolset can help you and your coworkers fix these issues.

There are already several nice Mock/Stub frameworks in the ruby world. These libraries include:
 * Mocha
 * Flexmock
 * Rspec's Mock Framework
